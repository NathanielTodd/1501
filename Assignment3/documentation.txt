For my implementation of CarTracker I used the book code (Princeton code linked on the class website) to implement my minimum priority queue (min heap). There are a number of reasons why I made this decision in which I will outline below.

For my explanations N will be the number of cars currently stored in the system.

Memory - One of the book implementation is the memory usage. It is based of a fixed maxN q
		queue size, which in this case is hardcoded into the program as 100. If the assignment had required or a more dynamic program were needed I would modify the program to vary the array size. This would be accomplished by making a new Priority queue of twice the size and copying the original contents into it. This still has the disadvantage of wasting memory. As the number of cars in the system gets larger there will be a lot of memory wasted because the entire array will be full in very few situations

		Despite this, I chose this implementation because the cars are being entered by hand one at a time. So it would take a lot of time and a lot of cars to fill up the allotted space of 100 cars. Additionally for a dynamically sized array, the amount of space wasted in the array will be relatively small based off of the number of cars that will be used to test our programs.

Runtime - Runtime is where the array based implmentation of the book has its advantages. I
		created a hashMap in order to accomplish indirection. This gives me constant runtime to
		access any element in the priority queue. With updates we can update any object with constant time and ensure the heap property is kept intact with theta(logN) runtime.
		Additionally, since we can access specific cars with constant time this means we can remove in theta(logN) time because after finding the car we simply need to swim or sink it. This traverses the height of the tree which is equal to log(N). This also works for insert. We can insert a new item at the last index in an array and swim it up, doing log(N) work. Again, since we can access items in constant time that means to remove any item we can access it, switch it with the last item in the queue and perform sink/swim to get theta(log(N)) time. Retrieval can be done in constant time for the min price and min mileage because we only need to look at the first index. Searching by make and model will converge to theta(N time in the worst case because I wrote a method in my priority queue that searches in level order for a car that matches the inputted make and model. This allows me to find the car of the specific make and model of highest priority.

In conclusion I chose to use the book'ss array based implementation of the priority queue because it gives me constant access time to any element without having to handle points to node objects. In particular it helps me when searching for the highest priority car based on make and model because I can do so by searching in level order without having to store extra references in my or in other structures. In practical use this approach would waste memory but I thought this tradeoff was worth it since we will be dealing with smaller quantities (limited by the number of cars we can input by hand) for this assignment.